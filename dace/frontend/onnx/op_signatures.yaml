# THIS FILE WAS GENERATED BY generate_op_signatures.py
Abs:
  attributes: {}
  inputs:
  - [X, T]
  outputs:
  - [Y, T]
  required: 1
  required_attributes: {}
  types:
    T: [uint8, uint16, uint32, uint64, int8, int16, int32, int64, float16, float32,
      float64]
Acos:
  attributes: {}
  inputs:
  - [input, T]
  outputs:
  - [output, T]
  required: 1
  required_attributes: {}
  types:
    T: [float16, float32, float64]
Acosh:
  attributes: {}
  inputs:
  - [input, T]
  outputs:
  - [output, T]
  required: 1
  required_attributes: {}
  types:
    T: [float16, float32, float64]
Add:
  attributes: {}
  inputs:
  - [A, T]
  - [B, T]
  outputs:
  - [C, T]
  required: 2
  required_attributes: {}
  types:
    T: [uint32, uint64, int32, int64, float16, float32, float64]
And:
  attributes: {}
  inputs:
  - [A, T]
  - [B, T]
  outputs:
  - [C, T1]
  required: 2
  required_attributes: {}
  types:
    T: [bool]
    T1: [bool]
ArgMax:
  attributes: {axis: 0, keepdims: 1}
  inputs:
  - [data, T]
  outputs:
  - [reduced, tensor(int64)]
  required: 1
  required_attributes: {}
  types:
    T: [uint8, uint16, uint32, uint64, int8, int16, int32, int64, float16, float32,
      float64]
ArgMin:
  attributes: {axis: 0, keepdims: 1}
  inputs:
  - [data, T]
  outputs:
  - [reduced, tensor(int64)]
  required: 1
  required_attributes: {}
  types:
    T: [uint8, uint16, uint32, uint64, int8, int16, int32, int64, float16, float32,
      float64]
ArrayFeatureExtractor:
  attributes: {}
  inputs:
  - [X, T]
  - [Y, tensor(int64)]
  outputs:
  - [Z, T]
  required: 2
  required_attributes: {}
  types:
    T: [float32, float64, int64, int32]
Asin:
  attributes: {}
  inputs:
  - [input, T]
  outputs:
  - [output, T]
  required: 1
  required_attributes: {}
  types:
    T: [float16, float32, float64]
Asinh:
  attributes: {}
  inputs:
  - [input, T]
  outputs:
  - [output, T]
  required: 1
  required_attributes: {}
  types:
    T: [float16, float32, float64]
Atan:
  attributes: {}
  inputs:
  - [input, T]
  outputs:
  - [output, T]
  required: 1
  required_attributes: {}
  types:
    T: [float16, float32, float64]
Atanh:
  attributes: {}
  inputs:
  - [input, T]
  outputs:
  - [output, T]
  required: 1
  required_attributes: {}
  types:
    T: [float16, float32, float64]
AveragePool:
  attributes:
    auto_pad: !!binary |
      Tk9UU0VU
    ceil_mode: 0
    count_include_pad: 0
  inputs:
  - [X, T]
  outputs:
  - [Y, T]
  required: 1
  required_attributes: {kernel_shape: INTS, pads: INTS, strides: INTS}
  types:
    T: [float16, float32, float64]
BatchNormalization:
  attributes: {epsilon: 9.999999747378752e-06, momentum: 0.8999999761581421}
  inputs:
  - [X, T]
  - [scale, T]
  - [B, T]
  - [mean, T]
  - [var, T]
  outputs:
  - [Y, T]
  - [mean, T]
  - [var, T]
  - [saved_mean, T]
  - [saved_var, T]
  required: 5
  required_attributes: {}
  types:
    T: [float16, float32, float64]
Binarizer:
  attributes: {threshold: 0.0}
  inputs:
  - [X, T]
  outputs:
  - [Y, T]
  required: 1
  required_attributes: {}
  types:
    T: [float32, float64, int64, int32]
BitShift:
  attributes: {}
  inputs:
  - [X, T]
  - [Y, T]
  outputs:
  - [Z, T]
  required: 2
  required_attributes: {direction: STRING}
  types:
    T: [uint8, uint16, uint32, uint64]
Cast:
  attributes: {}
  inputs:
  - [input, T1]
  outputs:
  - [output, T2]
  required: 1
  required_attributes: {to: INT}
  types:
    T1: [float16, float32, float64, int8, int16, int32, int64, uint8, uint16, uint32,
      uint64, bool]
    T2: [float16, float32, float64, int8, int16, int32, int64, uint8, uint16, uint32,
      uint64, bool]
CategoryMapper:
  attributes:
    default_int64: -1
    default_string: !!binary |
      X1VudXNlZA==
  inputs:
  - [X, T1]
  outputs:
  - [Y, T2]
  required: 1
  required_attributes: {cats_int64s: INTS, cats_strings: STRINGS}
  types:
    T1: [int64]
    T2: [int64]
Ceil:
  attributes: {}
  inputs:
  - [X, T]
  outputs:
  - [Y, T]
  required: 1
  required_attributes: {}
  types:
    T: [float16, float32, float64]
Clip:
  attributes: {}
  inputs:
  - [input, T]
  - [min, T]
  - [max, T]
  outputs:
  - [output, T]
  required: 1
  required_attributes: {}
  types:
    T: [float16, float32, float64]
Compress:
  attributes: {}
  inputs:
  - [input, T]
  - [condition, T1]
  outputs:
  - [output, T]
  required: 2
  required_attributes: {axis: INT}
  types:
    T: [uint8, uint16, uint32, uint64, int8, int16, int32, int64, float16, float32,
      float64, bool, complex64, complex128]
    T1: [bool]
Concat:
  attributes: {}
  inputs:
  - [inputs, T]
  outputs:
  - [concat_result, T]
  required: 1
  required_attributes: {axis: INT}
  types:
    T: [uint8, uint16, uint32, uint64, int8, int16, int32, int64, float16, float32,
      float64, bool, complex64, complex128]
Constant:
  attributes: {}
  inputs: []
  outputs:
  - [output, T]
  required: 0
  required_attributes: {sparse_value: SPARSE_TENSOR, value: TENSOR}
  types:
    T: [uint8, uint16, uint32, uint64, int8, int16, int32, int64, float16, float32,
      float64, bool, complex64, complex128]
ConstantOfShape:
  attributes: {}
  inputs:
  - [input, T1]
  outputs:
  - [output, T2]
  required: 1
  required_attributes: {value: TENSOR}
  types:
    T1: [int64]
    T2: [float16, float32, float64, int8, int16, int32, int64, uint8, uint16, uint32,
      uint64, bool]
Conv:
  attributes:
    auto_pad: !!binary |
      Tk9UU0VU
    group: 1
  inputs:
  - [X, T]
  - [W, T]
  - [B, T]
  outputs:
  - [Y, T]
  required: 2
  required_attributes: {dilations: INTS, kernel_shape: INTS, pads: INTS, strides: INTS}
  types:
    T: [float16, float32, float64]
ConvInteger:
  attributes:
    auto_pad: !!binary |
      Tk9UU0VU
    group: 1
  inputs:
  - [x, T1]
  - [w, T2]
  - [x_zero_point, T1]
  - [w_zero_point, T2]
  outputs:
  - [y, T3]
  required: 2
  required_attributes: {dilations: INTS, kernel_shape: INTS, pads: INTS, strides: INTS}
  types:
    T1: [int8, uint8]
    T2: [int8, uint8]
    T3: [int32]
ConvTranspose:
  attributes:
    auto_pad: !!binary |
      Tk9UU0VU
    group: 1
  inputs:
  - [X, T]
  - [W, T]
  - [B, T]
  outputs:
  - [Y, T]
  required: 2
  required_attributes: {dilations: INTS, kernel_shape: INTS, output_padding: INTS,
    output_shape: INTS, pads: INTS, strides: INTS}
  types:
    T: [float16, float32, float64]
Cos:
  attributes: {}
  inputs:
  - [input, T]
  outputs:
  - [output, T]
  required: 1
  required_attributes: {}
  types:
    T: [float16, float32, float64]
Cosh:
  attributes: {}
  inputs:
  - [input, T]
  outputs:
  - [output, T]
  required: 1
  required_attributes: {}
  types:
    T: [float16, float32, float64]
CumSum:
  attributes: {exclusive: 0, reverse: 0}
  inputs:
  - [x, T]
  - [axis, T2]
  outputs:
  - [y, T]
  required: 2
  required_attributes: {}
  types:
    T: [uint32, uint64, int32, int64, float32, float64]
    T2: [int32, int64]
DepthToSpace:
  attributes:
    mode: !!binary |
      RENS
  inputs:
  - [input, T]
  outputs:
  - [output, T]
  required: 1
  required_attributes: {blocksize: INT}
  types:
    T: [uint8, uint16, uint32, uint64, int8, int16, int32, int64, float16, float32,
      float64, bool, complex64, complex128]
DequantizeLinear:
  attributes: {}
  inputs:
  - [x, T]
  - [x_scale, tensor(float)]
  - [x_zero_point, T]
  outputs:
  - [y, tensor(float)]
  required: 2
  required_attributes: {}
  types:
    T: [int8, uint8, int32]
Det:
  attributes: {}
  inputs:
  - [X, T]
  outputs:
  - [Y, T]
  required: 1
  required_attributes: {}
  types:
    T: [float16, float32, float64]
Div:
  attributes: {}
  inputs:
  - [A, T]
  - [B, T]
  outputs:
  - [C, T]
  required: 2
  required_attributes: {}
  types:
    T: [uint32, uint64, int32, int64, float16, float32, float64]
Dropout:
  attributes: {ratio: 0.5}
  inputs:
  - [data, T]
  outputs:
  - [output, T]
  - [mask, T1]
  required: 1
  required_attributes: {}
  types:
    T: [float16, float32, float64]
    T1: [bool]
DynamicQuantizeLinear:
  attributes: {}
  inputs:
  - [x, T1]
  outputs:
  - [y, T2]
  - [y_scale, tensor(float)]
  - [y_zero_point, T2]
  required: 1
  required_attributes: {}
  types:
    T1: [float32]
    T2: [uint8]
Elu:
  attributes: {alpha: 1.0}
  inputs:
  - [X, T]
  outputs:
  - [Y, T]
  required: 1
  required_attributes: {}
  types:
    T: [float16, float32, float64]
Equal:
  attributes: {}
  inputs:
  - [A, T]
  - [B, T]
  outputs:
  - [C, T1]
  required: 2
  required_attributes: {}
  types:
    T: [bool, uint8, uint16, uint32, uint64, int8, int16, int32, int64, float16, float32,
      float64]
    T1: [bool]
Erf:
  attributes: {}
  inputs:
  - [input, T]
  outputs:
  - [output, T]
  required: 1
  required_attributes: {}
  types:
    T: [uint8, uint16, uint32, uint64, int8, int16, int32, int64, float16, float32,
      float64]
Exp:
  attributes: {}
  inputs:
  - [input, T]
  outputs:
  - [output, T]
  required: 1
  required_attributes: {}
  types:
    T: [float16, float32, float64]
Expand:
  attributes: {}
  inputs:
  - [input, T]
  - [shape, tensor(int64)]
  outputs:
  - [output, T]
  required: 2
  required_attributes: {}
  types:
    T: [uint8, uint16, uint32, uint64, int8, int16, int32, int64, float16, float32,
      float64, bool, complex64, complex128]
EyeLike:
  attributes: {k: 0}
  inputs:
  - [input, T1]
  outputs:
  - [output, T2]
  required: 1
  required_attributes: {dtype: INT}
  types:
    T1: [float16, float32, float64, int8, int16, int32, int64, uint8, uint16, uint32,
      uint64, bool]
    T2: [float16, float32, float64, int8, int16, int32, int64, uint8, uint16, uint32,
      uint64, bool]
FeatureVectorizer:
  attributes: {}
  inputs:
  - [X, T1]
  outputs:
  - [Y, tensor(float)]
  required: 1
  required_attributes: {inputdimensions: INTS}
  types:
    T1: [int32, int64, float32, float64]
Flatten:
  attributes: {axis: 1}
  inputs:
  - [input, T]
  outputs:
  - [output, T]
  required: 1
  required_attributes: {}
  types:
    T: [uint8, uint16, uint32, uint64, int8, int16, int32, int64, float16, float32,
      float64, bool, complex64, complex128]
Floor:
  attributes: {}
  inputs:
  - [X, T]
  outputs:
  - [Y, T]
  required: 1
  required_attributes: {}
  types:
    T: [float16, float32, float64]
GRU:
  attributes:
    direction: !!binary |
      Zm9yd2FyZA==
    linear_before_reset: 0
  inputs:
  - [X, T]
  - [W, T]
  - [R, T]
  - [B, T]
  - [sequence_lens, T1]
  - [initial_h, T]
  outputs:
  - [Y, T]
  - [Y_h, T]
  required: 3
  required_attributes: {activation_alpha: FLOATS, activation_beta: FLOATS, activations: STRINGS,
    clip: FLOAT, hidden_size: INT}
  types:
    T: [float16, float32, float64]
    T1: [int32]
Gather:
  attributes: {axis: 0}
  inputs:
  - [data, T]
  - [indices, Tind]
  outputs:
  - [output, T]
  required: 2
  required_attributes: {}
  types:
    T: [uint8, uint16, uint32, uint64, int8, int16, int32, int64, float16, float32,
      float64, bool, complex64, complex128]
    Tind: [int32, int64]
GatherElements:
  attributes: {axis: 0}
  inputs:
  - [data, T]
  - [indices, Tind]
  outputs:
  - [output, T]
  required: 2
  required_attributes: {}
  types:
    T: [uint8, uint16, uint32, uint64, int8, int16, int32, int64, float16, float32,
      float64, bool, complex64, complex128]
    Tind: [int32, int64]
GatherND:
  attributes: {}
  inputs:
  - [data, T]
  - [indices, tensor(int64)]
  outputs:
  - [output, T]
  required: 2
  required_attributes: {}
  types:
    T: [uint8, uint16, uint32, uint64, int8, int16, int32, int64, float16, float32,
      float64, bool, complex64, complex128]
Gemm:
  attributes: {alpha: 1.0, beta: 1.0, transA: 0, transB: 0}
  inputs:
  - [A, T]
  - [B, T]
  - [C, T]
  outputs:
  - [Y, T]
  required: 2
  required_attributes: {}
  types:
    T: [float16, float32, float64, uint32, uint64, int32, int64]
GlobalAveragePool:
  attributes: {}
  inputs:
  - [X, T]
  outputs:
  - [Y, T]
  required: 1
  required_attributes: {}
  types:
    T: [float16, float32, float64]
GlobalLpPool:
  attributes: {p: 2}
  inputs:
  - [X, T]
  outputs:
  - [Y, T]
  required: 1
  required_attributes: {}
  types:
    T: [float16, float32, float64]
GlobalMaxPool:
  attributes: {}
  inputs:
  - [X, T]
  outputs:
  - [Y, T]
  required: 1
  required_attributes: {}
  types:
    T: [float16, float32, float64]
Greater:
  attributes: {}
  inputs:
  - [A, T]
  - [B, T]
  outputs:
  - [C, T1]
  required: 2
  required_attributes: {}
  types:
    T: [uint8, uint16, uint32, uint64, int8, int16, int32, int64, float16, float32,
      float64]
    T1: [bool]
HardSigmoid:
  attributes: {alpha: 0.20000000298023224, beta: 0.5}
  inputs:
  - [X, T]
  outputs:
  - [Y, T]
  required: 1
  required_attributes: {}
  types:
    T: [float16, float32, float64]
Hardmax:
  attributes: {axis: 1}
  inputs:
  - [input, T]
  outputs:
  - [output, T]
  required: 1
  required_attributes: {}
  types:
    T: [float16, float32, float64]
Identity:
  attributes: {}
  inputs:
  - [input, T]
  outputs:
  - [output, T]
  required: 1
  required_attributes: {}
  types:
    T: [uint8, uint16, uint32, uint64, int8, int16, int32, int64, float16, float32,
      float64, bool, complex64, complex128]
If:
  attributes: {}
  inputs:
  - [cond, B]
  outputs:
  - [outputs, V]
  required: 1
  required_attributes: {else_branch: GRAPH, then_branch: GRAPH}
  types:
    B: [bool]
    V: [uint8, uint16, uint32, uint64, int8, int16, int32, int64, float16, float32,
      float64, bool, complex64, complex128]
Imputer:
  attributes: {replaced_value_float: 0.0, replaced_value_int64: 0}
  inputs:
  - [X, T]
  outputs:
  - [Y, T]
  required: 1
  required_attributes: {imputed_value_floats: FLOATS, imputed_value_int64s: INTS}
  types:
    T: [float32, float64, int64, int32]
InstanceNormalization:
  attributes: {epsilon: 9.999999747378752e-06}
  inputs:
  - [input, T]
  - [scale, T]
  - [B, T]
  outputs:
  - [output, T]
  required: 3
  required_attributes: {}
  types:
    T: [float16, float32, float64]
IsInf:
  attributes: {detect_negative: 1, detect_positive: 1}
  inputs:
  - [X, T1]
  outputs:
  - [Y, T2]
  required: 1
  required_attributes: {}
  types:
    T1: [float32, float64]
    T2: [bool]
IsNaN:
  attributes: {}
  inputs:
  - [X, T1]
  outputs:
  - [Y, T2]
  required: 1
  required_attributes: {}
  types:
    T1: [float16, float32, float64]
    T2: [bool]
LRN:
  attributes: {alpha: 9.999999747378752e-05, beta: 0.75, bias: 1.0}
  inputs:
  - [X, T]
  outputs:
  - [Y, T]
  required: 1
  required_attributes: {size: INT}
  types:
    T: [float16, float32, float64]
LSTM:
  attributes:
    direction: !!binary |
      Zm9yd2FyZA==
    input_forget: 0
  inputs:
  - [X, T]
  - [W, T]
  - [R, T]
  - [B, T]
  - [sequence_lens, T1]
  - [initial_h, T]
  - [initial_c, T]
  - [P, T]
  outputs:
  - [Y, T]
  - [Y_h, T]
  - [Y_c, T]
  required: 3
  required_attributes: {activation_alpha: FLOATS, activation_beta: FLOATS, activations: STRINGS,
    clip: FLOAT, hidden_size: INT}
  types:
    T: [float16, float32, float64]
    T1: [int32]
LabelEncoder:
  attributes:
    default_float: -0.0
    default_int64: -1
    default_string: !!binary |
      X1VudXNlZA==
  inputs:
  - [X, T1]
  outputs:
  - [Y, T2]
  required: 1
  required_attributes: {keys_floats: FLOATS, keys_int64s: INTS, keys_strings: STRINGS,
    values_floats: FLOATS, values_int64s: INTS, values_strings: STRINGS}
  types:
    T1: [int64, float32]
    T2: [int64, float32]
LeakyRelu:
  attributes: {alpha: 0.009999999776482582}
  inputs:
  - [X, T]
  outputs:
  - [Y, T]
  required: 1
  required_attributes: {}
  types:
    T: [float16, float32, float64]
Less:
  attributes: {}
  inputs:
  - [A, T]
  - [B, T]
  outputs:
  - [C, T1]
  required: 2
  required_attributes: {}
  types:
    T: [uint8, uint16, uint32, uint64, int8, int16, int32, int64, float16, float32,
      float64]
    T1: [bool]
LinearClassifier:
  attributes:
    multi_class: 0
    post_transform: !!binary |
      Tk9ORQ==
  inputs:
  - [X, T1]
  outputs:
  - [Y, T2]
  - [Z, tensor(float)]
  required: 1
  required_attributes: {classlabels_ints: INTS, classlabels_strings: STRINGS, coefficients: FLOATS,
    intercepts: FLOATS}
  types:
    T1: [float32, float64, int64, int32]
    T2: [int64]
LinearRegressor:
  attributes:
    post_transform: !!binary |
      Tk9ORQ==
    targets: 1
  inputs:
  - [X, T]
  outputs:
  - [Y, tensor(float)]
  required: 1
  required_attributes: {coefficients: FLOATS, intercepts: FLOATS}
  types:
    T: [float32, float64, int64, int32]
Log:
  attributes: {}
  inputs:
  - [input, T]
  outputs:
  - [output, T]
  required: 1
  required_attributes: {}
  types:
    T: [float16, float32, float64]
LogSoftmax:
  attributes: {axis: 1}
  inputs:
  - [input, T]
  outputs:
  - [output, T]
  required: 1
  required_attributes: {}
  types:
    T: [float16, float32, float64]
Loop:
  attributes: {}
  inputs:
  - [M, I]
  - [cond, B]
  - [v_initial, V]
  outputs:
  - [v_final_and_scan_outputs, V]
  required: 2
  required_attributes: {body: GRAPH}
  types:
    B: [bool]
    I: [int64]
    V: [uint8, uint16, uint32, uint64, int8, int16, int32, int64, float16, float32,
      float64, bool, complex64, complex128]
LpNormalization:
  attributes: {axis: -1, p: 2}
  inputs:
  - [input, T]
  outputs:
  - [output, T]
  required: 1
  required_attributes: {}
  types:
    T: [float16, float32, float64]
LpPool:
  attributes:
    auto_pad: !!binary |
      Tk9UU0VU
    p: 2
  inputs:
  - [X, T]
  outputs:
  - [Y, T]
  required: 1
  required_attributes: {kernel_shape: INTS, pads: INTS, strides: INTS}
  types:
    T: [float16, float32, float64]
MatMul:
  attributes: {}
  inputs:
  - [A, T]
  - [B, T]
  outputs:
  - [Y, T]
  required: 2
  required_attributes: {}
  types:
    T: [float16, float32, float64, uint32, uint64, int32, int64]
MatMulInteger:
  attributes: {}
  inputs:
  - [A, T1]
  - [B, T2]
  - [a_zero_point, T1]
  - [b_zero_point, T2]
  outputs:
  - [Y, T3]
  required: 2
  required_attributes: {}
  types:
    T1: [int8, uint8]
    T2: [int8, uint8]
    T3: [int32]
Max:
  attributes: {}
  inputs:
  - [data_0, T]
  outputs:
  - [max, T]
  required: 1
  required_attributes: {}
  types:
    T: [float16, float32, float64]
MaxPool:
  attributes:
    auto_pad: !!binary |
      Tk9UU0VU
    ceil_mode: 0
    storage_order: 0
  inputs:
  - [X, T]
  outputs:
  - [Y, T]
  - [Indices, I]
  required: 1
  required_attributes: {dilations: INTS, kernel_shape: INTS, pads: INTS, strides: INTS}
  types:
    I: [int64]
    T: [float16, float32, float64]
MaxRoiPool:
  attributes: {spatial_scale: 1.0}
  inputs:
  - [X, T]
  - [rois, T]
  outputs:
  - [Y, T]
  required: 2
  required_attributes: {pooled_shape: INTS}
  types:
    T: [float16, float32, float64]
MaxUnpool:
  attributes: {}
  inputs:
  - [X, T1]
  - [I, T2]
  - [output_shape, T2]
  outputs:
  - [output, T1]
  required: 2
  required_attributes: {kernel_shape: INTS, pads: INTS, strides: INTS}
  types:
    T1: [float16, float32, float64]
    T2: [int64]
Mean:
  attributes: {}
  inputs:
  - [data_0, T]
  outputs:
  - [mean, T]
  required: 1
  required_attributes: {}
  types:
    T: [float16, float32, float64]
MeanVarianceNormalization:
  attributes:
    axes: [0, 2, 3]
  inputs:
  - [X, T]
  outputs:
  - [Y, T]
  required: 1
  required_attributes: {}
  types:
    T: [float16, float32, float64]
Min:
  attributes: {}
  inputs:
  - [data_0, T]
  outputs:
  - [min, T]
  required: 1
  required_attributes: {}
  types:
    T: [float16, float32, float64]
Mod:
  attributes: {fmod: 0}
  inputs:
  - [A, T]
  - [B, T]
  outputs:
  - [C, T]
  required: 2
  required_attributes: {}
  types:
    T: [uint8, uint16, uint32, uint64, int8, int16, int32, int64, float16, float32,
      float64]
Mul:
  attributes: {}
  inputs:
  - [A, T]
  - [B, T]
  outputs:
  - [C, T]
  required: 2
  required_attributes: {}
  types:
    T: [uint32, uint64, int32, int64, float16, float32, float64]
Multinomial:
  attributes: {dtype: 6, sample_size: 1}
  inputs:
  - [input, T1]
  outputs:
  - [output, T2]
  required: 1
  required_attributes: {seed: FLOAT}
  types:
    T1: [float16, float32, float64]
    T2: [int32, int64]
Neg:
  attributes: {}
  inputs:
  - [X, T]
  outputs:
  - [Y, T]
  required: 1
  required_attributes: {}
  types:
    T: [float32, int32, int8, int16, int64, float16, float64]
NonMaxSuppression:
  attributes: {center_point_box: 0}
  inputs:
  - [boxes, tensor(float)]
  - [scores, tensor(float)]
  - [max_output_boxes_per_class, tensor(int64)]
  - [iou_threshold, tensor(float)]
  - [score_threshold, tensor(float)]
  outputs:
  - [selected_indices, tensor(int64)]
  required: 2
  required_attributes: {}
  types: {}
NonZero:
  attributes: {}
  inputs:
  - [X, T]
  outputs:
  - [Y, tensor(int64)]
  required: 1
  required_attributes: {}
  types:
    T: [uint8, uint16, uint32, uint64, int8, int16, int32, int64, float16, float32,
      float64, bool, complex64, complex128]
Normalizer:
  attributes:
    norm: !!binary |
      TUFY
  inputs:
  - [X, T]
  outputs:
  - [Y, tensor(float)]
  required: 1
  required_attributes: {}
  types:
    T: [float32, float64, int64, int32]
Not:
  attributes: {}
  inputs:
  - [X, T]
  outputs:
  - [Y, T]
  required: 1
  required_attributes: {}
  types:
    T: [bool]
OneHot:
  attributes: {axis: -1}
  inputs:
  - [indices, T1]
  - [depth, T2]
  - [values, T3]
  outputs:
  - [output, T3]
  required: 3
  required_attributes: {}
  types:
    T1: [uint8, uint16, uint32, uint64, int8, int16, int32, int64, float16, float32,
      float64]
    T2: [uint8, uint16, uint32, uint64, int8, int16, int32, int64, float16, float32,
      float64]
    T3: [uint8, uint16, uint32, uint64, int8, int16, int32, int64, float16, float32,
      float64, bool, complex64, complex128]
OneHotEncoder:
  attributes: {zeros: 1}
  inputs:
  - [X, T]
  outputs:
  - [Y, tensor(float)]
  required: 1
  required_attributes: {cats_int64s: INTS, cats_strings: STRINGS}
  types:
    T: [int64, int32, float32, float64]
Or:
  attributes: {}
  inputs:
  - [A, T]
  - [B, T]
  outputs:
  - [C, T1]
  required: 2
  required_attributes: {}
  types:
    T: [bool]
    T1: [bool]
PRelu:
  attributes: {}
  inputs:
  - [X, T]
  - [slope, T]
  outputs:
  - [Y, T]
  required: 2
  required_attributes: {}
  types:
    T: [float16, float32, float64, uint32, uint64, int32, int64]
Pad:
  attributes:
    mode: !!binary |
      Y29uc3RhbnQ=
  inputs:
  - [data, T]
  - [pads, tensor(int64)]
  - [constant_value, T]
  outputs:
  - [output, T]
  required: 2
  required_attributes: {}
  types:
    T: [uint8, uint16, uint32, uint64, int8, int16, int32, int64, float16, float32,
      float64]
Pow:
  attributes: {}
  inputs:
  - [X, T]
  - [Y, T]
  outputs:
  - [Z, T]
  required: 2
  required_attributes: {}
  types:
    T: [float16, float32, float64]
QLinearConv:
  attributes:
    auto_pad: !!binary |
      Tk9UU0VU
    group: 1
  inputs:
  - [x, T1]
  - [x_scale, tensor(float)]
  - [x_zero_point, T1]
  - [w, T2]
  - [w_scale, tensor(float)]
  - [w_zero_point, T2]
  - [y_scale, tensor(float)]
  - [y_zero_point, T3]
  - [B, T4]
  outputs:
  - [y, T3]
  required: 8
  required_attributes: {dilations: INTS, kernel_shape: INTS, pads: INTS, strides: INTS}
  types:
    T1: [int8, uint8]
    T2: [int8, uint8]
    T3: [int8, uint8]
    T4: [int32]
QLinearMatMul:
  attributes: {}
  inputs:
  - [a, T1]
  - [a_scale, tensor(float)]
  - [a_zero_point, T1]
  - [b, T2]
  - [b_scale, tensor(float)]
  - [b_zero_point, T2]
  - [y_scale, tensor(float)]
  - [y_zero_point, T3]
  outputs:
  - [y, T3]
  required: 8
  required_attributes: {}
  types:
    T1: [int8, uint8]
    T2: [int8, uint8]
    T3: [int8, uint8]
QuantizeLinear:
  attributes: {}
  inputs:
  - [x, T1]
  - [y_scale, tensor(float)]
  - [y_zero_point, T2]
  outputs:
  - [y, T2]
  required: 2
  required_attributes: {}
  types:
    T1: [float32, int32]
    T2: [int8, uint8]
RNN:
  attributes:
    activations:
    - !!binary |
      VGFuaA==
    - !!binary |
      VGFuaA==
    direction: !!binary |
      Zm9yd2FyZA==
  inputs:
  - [X, T]
  - [W, T]
  - [R, T]
  - [B, T]
  - [sequence_lens, T1]
  - [initial_h, T]
  outputs:
  - [Y, T]
  - [Y_h, T]
  required: 3
  required_attributes: {activation_alpha: FLOATS, activation_beta: FLOATS, clip: FLOAT,
    hidden_size: INT}
  types:
    T: [float16, float32, float64]
    T1: [int32]
RandomNormal:
  attributes: {dtype: 1, mean: 0.0, scale: 1.0}
  inputs: []
  outputs:
  - [output, T]
  required: 0
  required_attributes: {seed: FLOAT, shape: INTS}
  types:
    T: [float16, float32, float64]
RandomNormalLike:
  attributes: {mean: 0.0, scale: 1.0}
  inputs:
  - [input, T1]
  outputs:
  - [output, T2]
  required: 1
  required_attributes: {dtype: INT, seed: FLOAT}
  types:
    T1: [uint8, uint16, uint32, uint64, int8, int16, int32, int64, float16, float32,
      float64, bool, complex64, complex128]
    T2: [float16, float32, float64]
RandomUniform:
  attributes: {dtype: 1, high: 1.0, low: 0.0}
  inputs: []
  outputs:
  - [output, T]
  required: 0
  required_attributes: {seed: FLOAT, shape: INTS}
  types:
    T: [float16, float32, float64]
RandomUniformLike:
  attributes: {high: 1.0, low: 0.0}
  inputs:
  - [input, T1]
  outputs:
  - [output, T2]
  required: 1
  required_attributes: {dtype: INT, seed: FLOAT}
  types:
    T1: [uint8, uint16, uint32, uint64, int8, int16, int32, int64, float16, float32,
      float64, bool, complex64, complex128]
    T2: [float16, float32, float64]
Range:
  attributes: {}
  inputs:
  - [start, T]
  - [limit, T]
  - [delta, T]
  outputs:
  - [output, T]
  required: 3
  required_attributes: {}
  types:
    T: [float32, float64, int16, int32, int64]
Reciprocal:
  attributes: {}
  inputs:
  - [X, T]
  outputs:
  - [Y, T]
  required: 1
  required_attributes: {}
  types:
    T: [float16, float32, float64]
ReduceL1:
  attributes: {keepdims: 1}
  inputs:
  - [data, T]
  outputs:
  - [reduced, T]
  required: 1
  required_attributes: {axes: INTS}
  types:
    T: [uint32, uint64, int32, int64, float16, float32, float64]
ReduceL2:
  attributes: {keepdims: 1}
  inputs:
  - [data, T]
  outputs:
  - [reduced, T]
  required: 1
  required_attributes: {axes: INTS}
  types:
    T: [uint32, uint64, int32, int64, float16, float32, float64]
ReduceLogSum:
  attributes: {keepdims: 1}
  inputs:
  - [data, T]
  outputs:
  - [reduced, T]
  required: 1
  required_attributes: {axes: INTS}
  types:
    T: [uint32, uint64, int32, int64, float16, float32, float64]
ReduceLogSumExp:
  attributes: {keepdims: 1}
  inputs:
  - [data, T]
  outputs:
  - [reduced, T]
  required: 1
  required_attributes: {axes: INTS}
  types:
    T: [uint32, uint64, int32, int64, float16, float32, float64]
ReduceMax:
  attributes: {keepdims: 1}
  inputs:
  - [data, T]
  outputs:
  - [reduced, T]
  required: 1
  required_attributes: {axes: INTS}
  types:
    T: [uint32, uint64, int32, int64, float16, float32, float64]
ReduceMean:
  attributes: {keepdims: 1}
  inputs:
  - [data, T]
  outputs:
  - [reduced, T]
  required: 1
  required_attributes: {axes: INTS}
  types:
    T: [uint32, uint64, int32, int64, float16, float32, float64]
ReduceMin:
  attributes: {keepdims: 1}
  inputs:
  - [data, T]
  outputs:
  - [reduced, T]
  required: 1
  required_attributes: {axes: INTS}
  types:
    T: [uint32, uint64, int32, int64, float16, float32, float64]
ReduceProd:
  attributes: {keepdims: 1}
  inputs:
  - [data, T]
  outputs:
  - [reduced, T]
  required: 1
  required_attributes: {axes: INTS}
  types:
    T: [uint32, uint64, int32, int64, float16, float32, float64]
ReduceSum:
  attributes: {keepdims: 1}
  inputs:
  - [data, T]
  outputs:
  - [reduced, T]
  required: 1
  required_attributes: {axes: INTS}
  types:
    T: [uint32, uint64, int32, int64, float16, float32, float64]
ReduceSumSquare:
  attributes: {keepdims: 1}
  inputs:
  - [data, T]
  outputs:
  - [reduced, T]
  required: 1
  required_attributes: {axes: INTS}
  types:
    T: [uint32, uint64, int32, int64, float16, float32, float64]
Relu:
  attributes: {}
  inputs:
  - [X, T]
  outputs:
  - [Y, T]
  required: 1
  required_attributes: {}
  types:
    T: [float16, float32, float64]
Reshape:
  attributes: {}
  inputs:
  - [data, T]
  - [shape, tensor(int64)]
  outputs:
  - [reshaped, T]
  required: 2
  required_attributes: {}
  types:
    T: [uint8, uint16, uint32, uint64, int8, int16, int32, int64, float16, float32,
      float64, bool, complex64, complex128]
Resize:
  attributes:
    coordinate_transformation_mode: !!binary |
      aGFsZl9waXhlbA==
    cubic_coeff_a: -0.75
    exclude_outside: 0
    extrapolation_value: 0.0
    mode: !!binary |
      bmVhcmVzdA==
    nearest_mode: !!binary |
      cm91bmRfcHJlZmVyX2Zsb29y
  inputs:
  - [X, T1]
  - [roi, T2]
  - [scales, tensor(float)]
  - [sizes, tensor(int64)]
  outputs:
  - [Y, T1]
  required: 3
  required_attributes: {}
  types:
    T1: [uint8, uint16, uint32, uint64, int8, int16, int32, int64, float16, float32,
      float64, bool, complex64, complex128]
    T2: [float16, float32, float64]
ReverseSequence:
  attributes: {batch_axis: 1, time_axis: 0}
  inputs:
  - [input, T]
  - [sequence_lens, tensor(int64)]
  outputs:
  - [Y, T]
  required: 2
  required_attributes: {}
  types:
    T: [uint8, uint16, uint32, uint64, int8, int16, int32, int64, float16, float32,
      float64, bool, complex64, complex128]
RoiAlign:
  attributes:
    mode: !!binary |
      YXZn
    output_height: 1
    output_width: 1
    sampling_ratio: 0
    spatial_scale: 1.0
  inputs:
  - [X, T1]
  - [rois, T1]
  - [batch_indices, T2]
  outputs:
  - [Y, T1]
  required: 3
  required_attributes: {}
  types:
    T1: [float16, float32, float64]
    T2: [int64]
Round:
  attributes: {}
  inputs:
  - [X, T]
  outputs:
  - [Y, T]
  required: 1
  required_attributes: {}
  types:
    T: [float16, float32, float64]
SVMClassifier:
  attributes:
    kernel_type: !!binary |
      TElORUFS
    post_transform: !!binary |
      Tk9ORQ==
  inputs:
  - [X, T1]
  outputs:
  - [Y, T2]
  - [Z, tensor(float)]
  required: 1
  required_attributes: {classlabels_ints: INTS, classlabels_strings: STRINGS, coefficients: FLOATS,
    kernel_params: FLOATS, prob_a: FLOATS, prob_b: FLOATS, rho: FLOATS, support_vectors: FLOATS,
    vectors_per_class: INTS}
  types:
    T1: [float32, float64, int64, int32]
    T2: [int64]
SVMRegressor:
  attributes:
    kernel_type: !!binary |
      TElORUFS
    n_supports: 0
    one_class: 0
    post_transform: !!binary |
      Tk9ORQ==
  inputs:
  - [X, T]
  outputs:
  - [Y, tensor(float)]
  required: 1
  required_attributes: {coefficients: FLOATS, kernel_params: FLOATS, rho: FLOATS,
    support_vectors: FLOATS}
  types:
    T: [float32, float64, int64, int32]
Scaler:
  attributes: {}
  inputs:
  - [X, T]
  outputs:
  - [Y, tensor(float)]
  required: 1
  required_attributes: {offset: FLOATS, scale: FLOATS}
  types:
    T: [float32, float64, int64, int32]
Scan:
  attributes: {}
  inputs:
  - [initial_state_and_scan_inputs, V]
  outputs:
  - [final_state_and_scan_outputs, V]
  required: 1
  required_attributes: {body: GRAPH, num_scan_inputs: INT, scan_input_axes: INTS,
    scan_input_directions: INTS, scan_output_axes: INTS, scan_output_directions: INTS}
  types:
    I: [int64]
    V: [uint8, uint16, uint32, uint64, int8, int16, int32, int64, float16, float32,
      float64, bool, complex64, complex128]
Scatter:
  attributes: {axis: 0}
  inputs:
  - [data, T]
  - [indices, Tind]
  - [updates, T]
  outputs:
  - [output, T]
  required: 3
  required_attributes: {}
  types:
    T: [uint8, uint16, uint32, uint64, int8, int16, int32, int64, float16, float32,
      float64, bool, complex64, complex128]
    Tind: [int32, int64]
ScatterElements:
  attributes: {axis: 0}
  inputs:
  - [data, T]
  - [indices, Tind]
  - [updates, T]
  outputs:
  - [output, T]
  required: 3
  required_attributes: {}
  types:
    T: [uint8, uint16, uint32, uint64, int8, int16, int32, int64, float16, float32,
      float64, bool, complex64, complex128]
    Tind: [int32, int64]
ScatterND:
  attributes: {}
  inputs:
  - [data, T]
  - [indices, tensor(int64)]
  - [updates, T]
  outputs:
  - [output, T]
  required: 3
  required_attributes: {}
  types:
    T: [uint8, uint16, uint32, uint64, int8, int16, int32, int64, float16, float32,
      float64, bool, complex64, complex128]
Selu:
  attributes: {alpha: 1.6732631921768188, gamma: 1.0507010221481323}
  inputs:
  - [X, T]
  outputs:
  - [Y, T]
  required: 1
  required_attributes: {}
  types:
    T: [float16, float32, float64]
Shape:
  attributes: {}
  inputs:
  - [data, T]
  outputs:
  - [shape, T1]
  required: 1
  required_attributes: {}
  types:
    T: [uint8, uint16, uint32, uint64, int8, int16, int32, int64, float16, float32,
      float64, bool, complex64, complex128]
    T1: [int64]
Shrink:
  attributes: {bias: 0.0, lambd: 0.5}
  inputs:
  - [input, T]
  outputs:
  - [output, T]
  required: 1
  required_attributes: {}
  types:
    T: [uint8, uint16, uint32, uint64, int8, int16, int32, int64, float16, float32,
      float64]
Sigmoid:
  attributes: {}
  inputs:
  - [X, T]
  outputs:
  - [Y, T]
  required: 1
  required_attributes: {}
  types:
    T: [float16, float32, float64]
Sign:
  attributes: {}
  inputs:
  - [input, T]
  outputs:
  - [output, T]
  required: 1
  required_attributes: {}
  types:
    T: [uint8, uint16, uint32, uint64, int8, int16, int32, int64, float16, float32,
      float64]
Sin:
  attributes: {}
  inputs:
  - [input, T]
  outputs:
  - [output, T]
  required: 1
  required_attributes: {}
  types:
    T: [float16, float32, float64]
Sinh:
  attributes: {}
  inputs:
  - [input, T]
  outputs:
  - [output, T]
  required: 1
  required_attributes: {}
  types:
    T: [float16, float32, float64]
Size:
  attributes: {}
  inputs:
  - [data, T]
  outputs:
  - [size, T1]
  required: 1
  required_attributes: {}
  types:
    T: [uint8, uint16, uint32, uint64, int8, int16, int32, int64, float16, float32,
      float64, bool, complex64, complex128]
    T1: [int64]
Slice:
  attributes: {}
  inputs:
  - [data, T]
  - [starts, Tind]
  - [ends, Tind]
  - [axes, Tind]
  - [steps, Tind]
  outputs:
  - [output, T]
  required: 3
  required_attributes: {}
  types:
    T: [uint8, uint16, uint32, uint64, int8, int16, int32, int64, float16, float32,
      float64, bool, complex64, complex128]
    Tind: [int32, int64]
Softmax:
  attributes: {axis: 1}
  inputs:
  - [input, T]
  outputs:
  - [output, T]
  required: 1
  required_attributes: {}
  types:
    T: [float16, float32, float64]
Softplus:
  attributes: {}
  inputs:
  - [X, T]
  outputs:
  - [Y, T]
  required: 1
  required_attributes: {}
  types:
    T: [float16, float32, float64]
Softsign:
  attributes: {}
  inputs:
  - [input, T]
  outputs:
  - [output, T]
  required: 1
  required_attributes: {}
  types:
    T: [float16, float32, float64]
SpaceToDepth:
  attributes: {}
  inputs:
  - [input, T]
  outputs:
  - [output, T]
  required: 1
  required_attributes: {blocksize: INT}
  types:
    T: [uint8, uint16, uint32, uint64, int8, int16, int32, int64, float16, float32,
      float64, bool, complex64, complex128]
Split:
  attributes: {axis: 0}
  inputs:
  - [input, T]
  outputs:
  - [outputs, T]
  required: 1
  required_attributes: {split: INTS}
  types:
    T: [uint8, uint16, uint32, uint64, int8, int16, int32, int64, float16, float32,
      float64, bool, complex64, complex128]
Sqrt:
  attributes: {}
  inputs:
  - [X, T]
  outputs:
  - [Y, T]
  required: 1
  required_attributes: {}
  types:
    T: [float16, float32, float64]
Squeeze:
  attributes: {}
  inputs:
  - [data, T]
  outputs:
  - [squeezed, T]
  required: 1
  required_attributes: {axes: INTS}
  types:
    T: [uint8, uint16, uint32, uint64, int8, int16, int32, int64, float16, float32,
      float64, bool, complex64, complex128]
StringNormalizer:
  attributes:
    case_change_action: !!binary |
      Tk9ORQ==
    is_case_sensitive: 0
  inputs:
  - [X, tensor(string)]
  outputs:
  - [Y, tensor(string)]
  required: 1
  required_attributes: {locale: STRING, stopwords: STRINGS}
  types: {}
Sub:
  attributes: {}
  inputs:
  - [A, T]
  - [B, T]
  outputs:
  - [C, T]
  required: 2
  required_attributes: {}
  types:
    T: [uint32, uint64, int32, int64, float16, float32, float64]
Sum:
  attributes: {}
  inputs:
  - [data_0, T]
  outputs:
  - [sum, T]
  required: 1
  required_attributes: {}
  types:
    T: [float16, float32, float64]
Tan:
  attributes: {}
  inputs:
  - [input, T]
  outputs:
  - [output, T]
  required: 1
  required_attributes: {}
  types:
    T: [float16, float32, float64]
Tanh:
  attributes: {}
  inputs:
  - [input, T]
  outputs:
  - [output, T]
  required: 1
  required_attributes: {}
  types:
    T: [float16, float32, float64]
TfIdfVectorizer:
  attributes: {}
  inputs:
  - [X, T]
  outputs:
  - [Y, T1]
  required: 1
  required_attributes: {max_gram_length: INT, max_skip_count: INT, min_gram_length: INT,
    mode: STRING, ngram_counts: INTS, ngram_indexes: INTS, pool_int64s: INTS, pool_strings: STRINGS,
    weights: FLOATS}
  types:
    T: [int32, int64]
    T1: [float32]
ThresholdedRelu:
  attributes: {alpha: 1.0}
  inputs:
  - [X, T]
  outputs:
  - [Y, T]
  required: 1
  required_attributes: {}
  types:
    T: [float16, float32, float64]
Tile:
  attributes: {}
  inputs:
  - [input, T]
  - [repeats, T1]
  outputs:
  - [output, T]
  required: 2
  required_attributes: {}
  types:
    T: [uint8, uint16, uint32, uint64, int8, int16, int32, int64, float16, float32,
      float64, bool, complex64, complex128]
    T1: [int64]
TopK:
  attributes: {axis: -1, largest: 1, sorted: 1}
  inputs:
  - [X, T]
  - [K, tensor(int64)]
  outputs:
  - [Values, T]
  - [Indices, I]
  required: 2
  required_attributes: {}
  types:
    I: [int64]
    T: [uint8, uint16, uint32, uint64, int8, int16, int32, int64, float16, float32,
      float64]
Transpose:
  attributes: {}
  inputs:
  - [data, T]
  outputs:
  - [transposed, T]
  required: 1
  required_attributes: {perm: INTS}
  types:
    T: [uint8, uint16, uint32, uint64, int8, int16, int32, int64, float16, float32,
      float64, bool, complex64, complex128]
TreeEnsembleClassifier:
  attributes:
    post_transform: !!binary |
      Tk9ORQ==
  inputs:
  - [X, T1]
  outputs:
  - [Y, T2]
  - [Z, tensor(float)]
  required: 1
  required_attributes: {base_values: FLOATS, class_ids: INTS, class_nodeids: INTS,
    class_treeids: INTS, class_weights: FLOATS, classlabels_int64s: INTS, classlabels_strings: STRINGS,
    nodes_falsenodeids: INTS, nodes_featureids: INTS, nodes_hitrates: FLOATS, nodes_missing_value_tracks_true: INTS,
    nodes_modes: STRINGS, nodes_nodeids: INTS, nodes_treeids: INTS, nodes_truenodeids: INTS,
    nodes_values: FLOATS}
  types:
    T1: [float32, float64, int64, int32]
    T2: [int64]
TreeEnsembleRegressor:
  attributes:
    aggregate_function: !!binary |
      U1VN
    post_transform: !!binary |
      Tk9ORQ==
  inputs:
  - [X, T]
  outputs:
  - [Y, tensor(float)]
  required: 1
  required_attributes: {base_values: FLOATS, n_targets: INT, nodes_falsenodeids: INTS,
    nodes_featureids: INTS, nodes_hitrates: FLOATS, nodes_missing_value_tracks_true: INTS,
    nodes_modes: STRINGS, nodes_nodeids: INTS, nodes_treeids: INTS, nodes_truenodeids: INTS,
    nodes_values: FLOATS, target_ids: INTS, target_nodeids: INTS, target_treeids: INTS,
    target_weights: FLOATS}
  types:
    T: [float32, float64, int64, int32]
Unique:
  attributes: {sorted: 1}
  inputs:
  - [X, T]
  outputs:
  - [Y, T]
  - [indices, tensor(int64)]
  - [inverse_indices, tensor(int64)]
  - [counts, tensor(int64)]
  required: 1
  required_attributes: {axis: INT}
  types:
    T: [uint8, uint16, uint32, uint64, int8, int16, int32, int64, float16, float32,
      float64, bool, complex64, complex128]
Unsqueeze:
  attributes: {}
  inputs:
  - [data, T]
  outputs:
  - [expanded, T]
  required: 1
  required_attributes: {axes: INTS}
  types:
    T: [uint8, uint16, uint32, uint64, int8, int16, int32, int64, float16, float32,
      float64, bool, complex64, complex128]
Upsample:
  attributes:
    mode: !!binary |
      bmVhcmVzdA==
  inputs:
  - [X, T]
  - [scales, tensor(float)]
  outputs:
  - [Y, T]
  required: 2
  required_attributes: {}
  types:
    T: [uint8, uint16, uint32, uint64, int8, int16, int32, int64, float16, float32,
      float64, bool, complex64, complex128]
Where:
  attributes: {}
  inputs:
  - [condition, B]
  - [X, T]
  - [Y, T]
  outputs:
  - [output, T]
  required: 3
  required_attributes: {}
  types:
    B: [bool]
    T: [uint8, uint16, uint32, uint64, int8, int16, int32, int64, float16, float32,
      float64, bool, complex64, complex128]
Xor:
  attributes: {}
  inputs:
  - [A, T]
  - [B, T]
  outputs:
  - [C, T1]
  required: 2
  required_attributes: {}
  types:
    T: [bool]
    T1: [bool]
